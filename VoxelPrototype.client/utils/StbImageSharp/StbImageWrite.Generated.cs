// Generated by Sichem at 1/4/2022 10:31:08 AM

using VoxelPrototype.client.utils.StbImageSharp.Hebron.Runtime;

namespace VoxelPrototype.client.utils.StbImageSharp

{
    unsafe partial class StbImageWrite
	{
		public delegate void delegate0(void* arg0, void* arg1, int arg2);

		public static int stbi__flip_vertically_on_write;
		public static int stbi_write_force_png_filter = -1;
		public static int stbi_write_png_compression_level = 8;

		public static ushort[] stbi_zlib_compress_distc =
		{
			1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097,
			6145, 8193, 12289, 16385, 24577, 32768
		};

		public static byte[] stbi_zlib_compress_disteb =
			{0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13};

		public static ushort[] stbi_zlib_compress_lengthc =
		{
			3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195,
			227, 258, 259
		};

		public static byte[] stbi_zlib_compress_lengtheb =
			{0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0};

		public static uint[] stbiw__crc32_crc_table =
		{
			0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3, 0x0eDB8832,
			0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2,
			0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7, 0x136C9856, 0x646BA8C0, 0xFD62F97A,
			0x8A65C9EC, 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
			0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3,
			0x45DF5C75, 0xDCD60DCF, 0xABD13D59, 0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423,
			0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB,
			0xB6662D3D, 0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
			0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01, 0x6B6B51F4,
			0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,
			0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65, 0x4DB26158, 0x3AB551CE, 0xA3BC0074,
			0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
			0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525,
			0x206F85B3, 0xB966D409, 0xCE61E49F, 0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81,
			0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615,
			0x73DC1683, 0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
			0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7, 0xFED41B76,
			0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E,
			0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B, 0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6,
			0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
			0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7,
			0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D, 0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F,
			0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7,
			0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
			0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45, 0xA00AE278,
			0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC,
			0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9, 0xBDBDF21C, 0xCABAC28A, 0x53B39330,
			0x24B4A3A6, 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
			0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
		};

		public static int[] stbiw__encode_png_line_firstmap = { 0, 1, 0, 5, 6 };
		public static int[] stbiw__encode_png_line_mapping = { 0, 1, 2, 3, 4 };


		public static int stbi_write_png_to_func(delegate0 func, void* context, int x, int y, int comp, void* data,
			int stride_bytes)
		{
			var len = 0;
			var png = stbi_write_png_to_mem((byte*)data, stride_bytes, x, y, comp, &len);
			if (png == null)
				return 0;
			func(context, png, len);
			CRuntime.free(png);
			return 1;
		}
		public static void stbi_flip_vertically_on_write(int flag)
		{
			stbi__flip_vertically_on_write = flag;
		}
		public static void stbiw__write_flush(stbi__write_context s)
		{
			if (s.buf_used != 0)
			{
				fixed (byte* bptr = s.buffer)
				{
					s.func(s.context, bptr, s.buf_used);
				}

				s.buf_used = 0;
			}
		}
		public static void* stbiw__sbgrowf(void** arr, int increment, int itemsize)
		{
			var m = *arr != null ? 2 * ((int*)*arr - 2)[0] + increment : increment + 1;
			var p = CRuntime.realloc(*arr != null ? (int*)*arr - 2 : null, (ulong)(itemsize * m + sizeof(int) * 2));
			if (p != null)
			{
				if (*arr == null)
					((int*)p)[1] = 0;
				*arr = (int*)p + 2;
				((int*)*arr - 2)[0] = m;
			}

			return *arr;
		}

		public static byte* stbiw__zlib_flushf(byte* data, uint* bitbuffer, int* bitcount)
		{
			while (*bitcount >= 8)
			{
				if (data == null || ((int*)data - 2)[1] + 1 >= ((int*)data - 2)[0])
					stbiw__sbgrowf((void**)&data, 1, sizeof(byte));
				var index = ((int*)data - 2)[1]++;
				var value = (byte)(*bitbuffer & 0xff);
				data[index] = value;
				*bitbuffer >>= 8;
				*bitcount -= 8;
			}

			return data;
		}

		public static int stbiw__zlib_bitrev(int code, int codebits)
		{
			var res = 0;
			while (codebits-- != 0)
			{
				res = (res << 1) | (code & 1);
				code >>= 1;
			}

			return res;
		}

		public static uint stbiw__zlib_countm(byte* a, byte* b, int limit)
		{
			var i = 0;
			for (i = 0; i < limit && i < 258; ++i)
				if (a[i] != b[i])
					break;
			return (uint)i;
		}

		public static uint stbiw__zhash(byte* data)
		{
			var hash = (uint)(data[0] + (data[1] << 8) + (data[2] << 16));
			hash ^= hash << 3;
			hash += hash >> 5;
			hash ^= hash << 4;
			hash += hash >> 17;
			hash ^= hash << 25;
			hash += hash >> 6;
			return hash;
		}

		public static byte* stbi_zlib_compress(byte* data, int data_len, int* out_len, int quality)
		{
			uint bitbuf = 0;
			var i = 0;
			var j = 0;
			var bitcount = 0;
			byte* _out_ = null;
			var hash_table = (byte***)CRuntime.malloc((ulong)(16384 * sizeof(byte**)));
			if (hash_table == null)
				return null;
			if (quality < 5)
				quality = 5;
			if (_out_ == null || ((int*)_out_ - 2)[1] + 1 >= ((int*)_out_ - 2)[0])
				stbiw__sbgrowf((void**)&_out_, 1, sizeof(byte));
			_out_[((int*)_out_ - 2)[1]++] = 0x78;
			if (_out_ == null || ((int*)_out_ - 2)[1] + 1 >= ((int*)_out_ - 2)[0])
				stbiw__sbgrowf((void**)&_out_, 1, sizeof(byte));
			_out_[((int*)_out_ - 2)[1]++] = 0x5e;
			{
				bitbuf |= (uint)(1 << bitcount);
				bitcount += 1;
				_out_ = stbiw__zlib_flushf(_out_, &bitbuf, &bitcount);
			}

			{
				bitbuf |= (uint)(1 << bitcount);
				bitcount += 2;
				_out_ = stbiw__zlib_flushf(_out_, &bitbuf, &bitcount);
			}

			for (i = 0; i < 16384; ++i)
				hash_table[i] = null;
			i = 0;
			while (i < data_len - 3)
			{
				var h = (int)(stbiw__zhash(data + i) & (16384 - 1));
				var best = 3;
				byte* bestloc = null;
				var hlist = hash_table[h];
				var n = hlist != null ? ((int*)hlist - 2)[1] : 0;
				for (j = 0; j < n; ++j)
					if (hlist[j] - data > i - 32768)
					{
						var d = (int)stbiw__zlib_countm(hlist[j], data + i, data_len - i);
						if (d >= best)
						{
							best = d;
							bestloc = hlist[j];
						}
					}

				if (hash_table[h] != null && ((int*)hash_table[h] - 2)[1] == 2 * quality)
				{
					CRuntime.memmove(hash_table[h], hash_table[h] + quality, (ulong)(sizeof(byte*) * quality));
					((int*)hash_table[h] - 2)[1] = quality;
				}

				if (hash_table[h] == null || ((int*)hash_table[h] - 2)[1] + 1 >= ((int*)hash_table[h] - 2)[0])
					stbiw__sbgrowf((void**)&hash_table[h], 1, sizeof(byte*));
				hash_table[h][((int*)hash_table[h] - 2)[1]++] = data + i;
				if (bestloc != null)
				{
					h = (int)(stbiw__zhash(data + i + 1) & (16384 - 1));
					hlist = hash_table[h];
					n = hlist != null ? ((int*)hlist - 2)[1] : 0;
					for (j = 0; j < n; ++j)
						if (hlist[j] - data > i - 32767)
						{
							var e = (int)stbiw__zlib_countm(hlist[j], data + i + 1, data_len - i - 1);
							if (e > best)
							{
								bestloc = null;
								break;
							}
						}
				}

				if (bestloc != null)
				{
					var d = (int)(data + i - bestloc);
					for (j = 0; best > stbi_zlib_compress_lengthc[j + 1] - 1; ++j)
					{
					}

					if (j + 257 <= 143)
					{
						bitbuf |= (uint)(stbiw__zlib_bitrev(0x30 + j + 257, 8) << bitcount);
						bitcount += 8;
						_out_ = stbiw__zlib_flushf(_out_, &bitbuf, &bitcount);
					}
					else if (j + 257 <= 255)
					{
						bitbuf |= (uint)(stbiw__zlib_bitrev(0x190 + j + 257 - 144, 9) << bitcount);
						bitcount += 9;
						_out_ = stbiw__zlib_flushf(_out_, &bitbuf, &bitcount);
					}
					else if (j + 257 <= 279)
					{
						bitbuf |= (uint)(stbiw__zlib_bitrev(0 + j + 257 - 256, 7) << bitcount);
						bitcount += 7;
						_out_ = stbiw__zlib_flushf(_out_, &bitbuf, &bitcount);
					}
					else
					{
						bitbuf |= (uint)(stbiw__zlib_bitrev(0xc0 + j + 257 - 280, 8) << bitcount);
						bitcount += 8;
						_out_ = stbiw__zlib_flushf(_out_, &bitbuf, &bitcount);
					}

					if (stbi_zlib_compress_lengtheb[j] != 0)
					{
						bitbuf |= (uint)((best - stbi_zlib_compress_lengthc[j]) << bitcount);
						bitcount += stbi_zlib_compress_lengtheb[j];
						_out_ = stbiw__zlib_flushf(_out_, &bitbuf, &bitcount);
					}

					for (j = 0; d > stbi_zlib_compress_distc[j + 1] - 1; ++j)
					{
					}

					{
						bitbuf |= (uint)(stbiw__zlib_bitrev(j, 5) << bitcount);
						bitcount += 5;
						_out_ = stbiw__zlib_flushf(_out_, &bitbuf, &bitcount);
					}

					if (stbi_zlib_compress_disteb[j] != 0)
					{
						bitbuf |= (uint)((d - stbi_zlib_compress_distc[j]) << bitcount);
						bitcount += stbi_zlib_compress_disteb[j];
						_out_ = stbiw__zlib_flushf(_out_, &bitbuf, &bitcount);
					}

					i += best;
				}
				else
				{
					if (data[i] <= 143)
					{
						bitbuf |= (uint)(stbiw__zlib_bitrev(0x30 + data[i], 8) << bitcount);
						bitcount += 8;
						_out_ = stbiw__zlib_flushf(_out_, &bitbuf, &bitcount);
					}
					else
					{
						bitbuf |= (uint)(stbiw__zlib_bitrev(0x190 + data[i] - 144, 9) << bitcount);
						bitcount += 9;
						_out_ = stbiw__zlib_flushf(_out_, &bitbuf, &bitcount);
					}

					++i;
				}
			}

			for (; i < data_len; ++i)
				if (data[i] <= 143)
				{
					bitbuf |= (uint)(stbiw__zlib_bitrev(0x30 + data[i], 8) << bitcount);
					bitcount += 8;
					_out_ = stbiw__zlib_flushf(_out_, &bitbuf, &bitcount);
				}
				else
				{
					bitbuf |= (uint)(stbiw__zlib_bitrev(0x190 + data[i] - 144, 9) << bitcount);
					bitcount += 9;
					_out_ = stbiw__zlib_flushf(_out_, &bitbuf, &bitcount);
				}

			if (256 <= 143)
			{
				bitbuf |= (uint)(stbiw__zlib_bitrev(0x30 + 256, 8) << bitcount);
				bitcount += 8;
				_out_ = stbiw__zlib_flushf(_out_, &bitbuf, &bitcount);
			}

			if (256 <= 255)
			{
				bitbuf |= (uint)(stbiw__zlib_bitrev(0x190 + 256 - 144, 9) << bitcount);
				bitcount += 9;
				_out_ = stbiw__zlib_flushf(_out_, &bitbuf, &bitcount);
			}

			if (256 <= 279)
			{
				bitbuf |= (uint)(stbiw__zlib_bitrev(0 + 256 - 256, 7) << bitcount);
				bitcount += 7;
				_out_ = stbiw__zlib_flushf(_out_, &bitbuf, &bitcount);
			}
			else
			{
				bitbuf |= (uint)(stbiw__zlib_bitrev(0xc0 + 256 - 280, 8) << bitcount);
				bitcount += 8;
				_out_ = stbiw__zlib_flushf(_out_, &bitbuf, &bitcount);
			}

			while (bitcount != 0)
			{
				bitbuf |= (uint)(0 << bitcount);
				bitcount += 1;
				_out_ = stbiw__zlib_flushf(_out_, &bitbuf, &bitcount);
			}

			for (i = 0; i < 16384; ++i)
				if (hash_table[i] != null)
					CRuntime.free((int*)hash_table[i] - 2);
			CRuntime.free(hash_table);
			if (((int*)_out_ - 2)[1] > data_len + 2 + (data_len + 32766) / 32767 * 5)
			{
				((int*)_out_ - 2)[1] = 2;
				for (j = 0; j < data_len;)
				{
					var blocklen = data_len - j;
					if (blocklen > 32767)
						blocklen = 32767;
					if (_out_ == null || ((int*)_out_ - 2)[1] + 1 >= ((int*)_out_ - 2)[0])
						stbiw__sbgrowf((void**)&_out_, 1, sizeof(byte));
					_out_[((int*)_out_ - 2)[1]++] = (byte)(data_len - j == blocklen ? 1 : 0);
					if (_out_ == null || ((int*)_out_ - 2)[1] + 1 >= ((int*)_out_ - 2)[0])
						stbiw__sbgrowf((void**)&_out_, 1, sizeof(byte));
					_out_[((int*)_out_ - 2)[1]++] = (byte)(blocklen & 0xff);
					if (_out_ == null || ((int*)_out_ - 2)[1] + 1 >= ((int*)_out_ - 2)[0])
						stbiw__sbgrowf((void**)&_out_, 1, sizeof(byte));
					_out_[((int*)_out_ - 2)[1]++] = (byte)((blocklen >> 8) & 0xff);
					if (_out_ == null || ((int*)_out_ - 2)[1] + 1 >= ((int*)_out_ - 2)[0])
						stbiw__sbgrowf((void**)&_out_, 1, sizeof(byte));
					_out_[((int*)_out_ - 2)[1]++] = (byte)(~blocklen & 0xff);
					if (_out_ == null || ((int*)_out_ - 2)[1] + 1 >= ((int*)_out_ - 2)[0])
						stbiw__sbgrowf((void**)&_out_, 1, sizeof(byte));
					_out_[((int*)_out_ - 2)[1]++] = (byte)((~blocklen >> 8) & 0xff);
					CRuntime.memcpy(_out_ + ((int*)_out_ - 2)[1], data + j, (ulong)blocklen);
					((int*)_out_ - 2)[1] += blocklen;
					j += blocklen;
				}
			}

			{
				uint s1 = 1;
				uint s2 = 0;
				var blocklen = data_len % 5552;
				j = 0;
				while (j < data_len)
				{
					for (i = 0; i < blocklen; ++i)
					{
						s1 += data[j + i];
						s2 += s1;
					}

					s1 %= 65521;
					s2 %= 65521;
					j += blocklen;
					blocklen = 5552;
				}

				if (_out_ == null || ((int*)_out_ - 2)[1] + 1 >= ((int*)_out_ - 2)[0])
					stbiw__sbgrowf((void**)&_out_, 1, sizeof(byte));
				_out_[((int*)_out_ - 2)[1]++] = (byte)((s2 >> 8) & 0xff);
				if (_out_ == null || ((int*)_out_ - 2)[1] + 1 >= ((int*)_out_ - 2)[0])
					stbiw__sbgrowf((void**)&_out_, 1, sizeof(byte));
				_out_[((int*)_out_ - 2)[1]++] = (byte)(s2 & 0xff);
				if (_out_ == null || ((int*)_out_ - 2)[1] + 1 >= ((int*)_out_ - 2)[0])
					stbiw__sbgrowf((void**)&_out_, 1, sizeof(byte));
				_out_[((int*)_out_ - 2)[1]++] = (byte)((s1 >> 8) & 0xff);
				if (_out_ == null || ((int*)_out_ - 2)[1] + 1 >= ((int*)_out_ - 2)[0])
					stbiw__sbgrowf((void**)&_out_, 1, sizeof(byte));
				_out_[((int*)_out_ - 2)[1]++] = (byte)(s1 & 0xff);
			}

			*out_len = ((int*)_out_ - 2)[1];
			CRuntime.memmove((int*)_out_ - 2, _out_, (ulong)*out_len);
			return (byte*)((int*)_out_ - 2);
		}

		public static uint stbiw__crc32(byte* buffer, int len)
		{
			var crc = ~0u;
			var i = 0;
			for (i = 0; i < len; ++i)
				crc = (crc >> 8) ^ stbiw__crc32_crc_table[buffer[i] ^ (crc & 0xff)];
			return ~crc;
		}

		public static void stbiw__wpcrc(byte** data, int len)
		{
			var crc = stbiw__crc32(*data - len - 4, len + 4);
			(*data)[0] = (byte)((crc >> 24) & 0xff);
			(*data)[1] = (byte)((crc >> 16) & 0xff);
			(*data)[2] = (byte)((crc >> 8) & 0xff);
			(*data)[3] = (byte)(crc & 0xff);
			(*data) += 4;
		}

		public static byte stbiw__paeth(int a, int b, int c)
		{
			var p = a + b - c;
			var pa = Math.Abs(p - a);
			var pb = Math.Abs(p - b);
			var pc = Math.Abs(p - c);
			if (pa <= pb && pa <= pc)
				return (byte)(a & 0xff);
			if (pb <= pc)
				return (byte)(b & 0xff);
			return (byte)(c & 0xff);
		}

		public static void stbiw__encode_png_line(byte* pixels, int stride_bytes, int width, int height, int y, int n,
			int filter_type, sbyte* line_buffer)
		{
			var mymap = y != 0 ? stbiw__encode_png_line_mapping : stbiw__encode_png_line_firstmap;
			var i = 0;
			var type = mymap[filter_type];
			var z = pixels + stride_bytes * (stbi__flip_vertically_on_write != 0 ? height - 1 - y : y);
			var signed_stride = stbi__flip_vertically_on_write != 0 ? -stride_bytes : stride_bytes;
			if (type == 0)
			{
				CRuntime.memcpy(line_buffer, z, (ulong)(width * n));
				return;
			}

			for (i = 0; i < n; ++i)
				switch (type)
				{
					case 1:
						line_buffer[i] = (sbyte)z[i];
						break;
					case 2:
						line_buffer[i] = (sbyte)(z[i] - z[i - signed_stride]);
						break;
					case 3:
						line_buffer[i] = (sbyte)(z[i] - (z[i - signed_stride] >> 1));
						break;
					case 4:
						line_buffer[i] = (sbyte)(z[i] - stbiw__paeth(0, z[i - signed_stride], 0));
						break;
					case 5:
						line_buffer[i] = (sbyte)z[i];
						break;
					case 6:
						line_buffer[i] = (sbyte)z[i];
						break;
				}

			switch (type)
			{
				case 1:
					for (i = n; i < width * n; ++i)
						line_buffer[i] = (sbyte)(z[i] - z[i - n]);
					break;
				case 2:
					for (i = n; i < width * n; ++i)
						line_buffer[i] = (sbyte)(z[i] - z[i - signed_stride]);
					break;
				case 3:
					for (i = n; i < width * n; ++i)
						line_buffer[i] = (sbyte)(z[i] - ((z[i - n] + z[i - signed_stride]) >> 1));
					break;
				case 4:
					for (i = n; i < width * n; ++i)
						line_buffer[i] =
							(sbyte)(z[i] - stbiw__paeth(z[i - n], z[i - signed_stride], z[i - signed_stride - n]));
					break;
				case 5:
					for (i = n; i < width * n; ++i)
						line_buffer[i] = (sbyte)(z[i] - (z[i - n] >> 1));
					break;
				case 6:
					for (i = n; i < width * n; ++i)
						line_buffer[i] = (sbyte)(z[i] - stbiw__paeth(z[i - n], 0, 0));
					break;
			}
		}

		public static byte* stbi_write_png_to_mem(byte* pixels, int stride_bytes, int x, int y, int n, int* out_len)
		{
			var force_filter = stbi_write_force_png_filter;
			var ctype = stackalloc int[] { -1, 0, 4, 2, 6 };
			var sig = stackalloc byte[] { 137, 80, 78, 71, 13, 10, 26, 10 };
			byte* _out_;
			byte* o;
			byte* filt;
			byte* zlib;
			sbyte* line_buffer;
			var j = 0;
			var zlen = 0;
			if (stride_bytes == 0)
				stride_bytes = x * n;
			if (force_filter >= 5)
				force_filter = -1;
			filt = (byte*)CRuntime.malloc((ulong)((x * n + 1) * y));
			if (filt == null)
				return null;
			line_buffer = (sbyte*)CRuntime.malloc((ulong)(x * n));
			if (line_buffer == null)
			{
				CRuntime.free(filt);
				return null;
			}

			for (j = 0; j < y; ++j)
			{
				var filter_type = 0;
				if (force_filter > -1)
				{
					filter_type = force_filter;
					stbiw__encode_png_line(pixels, stride_bytes, x, y, j, n, force_filter, line_buffer);
				}
				else
				{
					var best_filter = 0;
					var best_filter_val = 0x7fffffff;
					var est = 0;
					var i = 0;
					for (filter_type = 0; filter_type < 5; filter_type++)
					{
						stbiw__encode_png_line(pixels, stride_bytes, x, y, j, n, filter_type, line_buffer);
						est = 0;
						for (i = 0; i < x * n; ++i)
							est += (int)Math.Abs((int)line_buffer[i]);
						if (est < best_filter_val)
						{
							best_filter_val = est;
							best_filter = filter_type;
						}
					}

					if (filter_type != best_filter)
					{
						stbiw__encode_png_line(pixels, stride_bytes, x, y, j, n, best_filter, line_buffer);
						filter_type = best_filter;
					}
				}

				filt[j * (x * n + 1)] = (byte)filter_type;
				CRuntime.memmove(filt + j * (x * n + 1) + 1, line_buffer, (ulong)(x * n));
			}

			CRuntime.free(line_buffer);
			zlib = stbi_zlib_compress(filt, y * (x * n + 1), &zlen, stbi_write_png_compression_level);
			CRuntime.free(filt);
			if (zlib == null)
				return null;
			_out_ = (byte*)CRuntime.malloc((ulong)(8 + 12 + 13 + 12 + zlen + 12));
			if (_out_ == null)
				return null;
			*out_len = 8 + 12 + 13 + 12 + zlen + 12;
			o = _out_;
			CRuntime.memmove(o, sig, (ulong)8);
			o += 8;
			o[0] = (13 >> 24) & 0xff;
			o[1] = (13 >> 16) & 0xff;
			o[2] = (13 >> 8) & 0xff;
			o[3] = 13 & 0xff;
			o += 4;
			o[0] = (byte)("IHDR"[0] & 0xff);
			o[1] = (byte)("IHDR"[1] & 0xff);
			o[2] = (byte)("IHDR"[2] & 0xff);
			o[3] = (byte)("IHDR"[3] & 0xff);
			o += 4;
			o[0] = (byte)((x >> 24) & 0xff);
			o[1] = (byte)((x >> 16) & 0xff);
			o[2] = (byte)((x >> 8) & 0xff);
			o[3] = (byte)(x & 0xff);
			o += 4;
			o[0] = (byte)((y >> 24) & 0xff);
			o[1] = (byte)((y >> 16) & 0xff);
			o[2] = (byte)((y >> 8) & 0xff);
			o[3] = (byte)(y & 0xff);
			o += 4;
			*o++ = 8;
			*o++ = (byte)(ctype[n] & 0xff);
			*o++ = 0;
			*o++ = 0;
			*o++ = 0;
			stbiw__wpcrc(&o, 13);
			o[0] = (byte)((zlen >> 24) & 0xff);
			o[1] = (byte)((zlen >> 16) & 0xff);
			o[2] = (byte)((zlen >> 8) & 0xff);
			o[3] = (byte)(zlen & 0xff);
			o += 4;
			o[0] = (byte)("IDAT"[0] & 0xff);
			o[1] = (byte)("IDAT"[1] & 0xff);
			o[2] = (byte)("IDAT"[2] & 0xff);
			o[3] = (byte)("IDAT"[3] & 0xff);
			o += 4;
			CRuntime.memmove(o, zlib, (ulong)zlen);
			o += zlen;
			CRuntime.free(zlib);
			stbiw__wpcrc(&o, zlen);
			o[0] = (0 >> 24) & 0xff;
			o[1] = (0 >> 16) & 0xff;
			o[2] = (0 >> 8) & 0xff;
			o[3] = 0 & 0xff;
			o += 4;
			o[0] = (byte)("IEND"[0] & 0xff);
			o[1] = (byte)("IEND"[1] & 0xff);
			o[2] = (byte)("IEND"[2] & 0xff);
			o[3] = (byte)("IEND"[3] & 0xff);
			o += 4;
			stbiw__wpcrc(&o, 0);
			return _out_;
		}
		public class stbi__write_context
		{
			public int buf_used;
			public byte[] buffer = new byte[64];
			public void* context;
			public delegate0 func;
		}
	}
}